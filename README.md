_01_simple_factory      简单工厂模式:由工厂类根据传入的参数实例化相应的产品类。

_02_strategy            策略模式:策略是对算法的封装，是一种形为模式，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。

_06_decorator           装饰者模式:在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。

_07_proxy               代理模式:为其他对象提供一种代理以控制对这个对象的访问。

_08_factory_method      工厂方法模式:把简单工厂的内部逻辑判断移到了客户端，由客户端决定实例化哪一个产品类。

_09_prototype           原型模式:通过拷贝创建新的对象。

_10_template_method     模板方法模式:定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

_12_facade              外观模式:为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

_13_builder             建造者模式:将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

_14_observer            观察者模式:定义了一种一对多的依赖关系，让多个观察这对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。

_15_abstract_factory    抽象工厂模式:提供一个创建一系利相关或相互依赖对象的接口，而无需指定他们具体的类。

_17_adapter             适配器模式:将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。

_18_memento             备忘录模式:在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

_19_composite           组合模式:将对象组合成树形结构表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

_22_bridge              桥接模式:将抽象部分与它的实现部分分离，使它们都可以独立的变化。

_23_command             命令模式:将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

_24_COR                 责任链模式:使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

_25_mediator            中介者模式:用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式的相互作用，从而使它们耦合松散，而且可以独立地改变它们之间的交互。